// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2783.BasicTankDriveBase.robot;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import java.io.File;
import java.io.IOException;
import java.util.Random;

import org.usfirst.frc2783.BasicTankDriveBase.commands.*;
import org.usfirst.frc2783.BasicTankDriveBase.subsystems.*;
import org.usfirst.frc2783.BasicTankDriveBase.util.Logger;
import org.usfirst.frc2783.BasicTankDriveBase.robot.Robot;
import org.usfirst.frc2783.BasicTankDriveBase.util.NavSensor;
import org.usfirst.frc2783.BasicTankDriveBase.subsystems.TankDriveBase;
import org.usfirst.frc2783.BasicTankDriveBase.autonomous.ActionGroup;
import org.usfirst.frc2783.BasicTankDriveBase.autonomous.ActionScheduler;
import org.usfirst.frc2783.BasicTankDriveBase.autonomous.TandemAction;
import org.usfirst.frc2783.BasicTankDriveBase.loops.LeftEncoderCounter;
import org.usfirst.frc2783.BasicTankDriveBase.loops.RightEncoderCounter;
import org.usfirst.frc2783.BasicTankDriveBase.loops.Looper;

import com.kauailabs.navx.frc.AHRS;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the TimedRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the build.properties file in 
 * the project.
 */
public class Robot extends TimedRobot {

    Command autonomousCommand;
    SendableChooser<Command> chooser = new SendableChooser<>();

    public static OI oi;
    
    public static Looper looper = new Looper();
    
    private static AHRS navSensor;
    
    public static String gameData;
	public static String switchesVal;
	public static String scaleVal;
	
	public static Random rand = new Random();
	
	public static TankDriveBase tankDrive = new TankDriveBase();
	
	public static LeftEncoderCounter leftCounter = new LeftEncoderCounter();
	public static RightEncoderCounter rightCounter = new RightEncoderCounter();
	
	public static AnalogInput leftAbsEnc = new AnalogInput(0);
	public static AnalogInput rightAbsEnc = new AnalogInput(1);
	
	public double leftTotalAngle = 0;
	public double rightTotalAngle = 0;
    
	public static ActionScheduler autoScheduler = new ActionScheduler();
	public static TandemAction tandemAction = new TandemAction();
	
	public void setGroup(ActionGroup group) {
		autoScheduler.setGroup(group);
		tandemAction.setGroup(group);
	}
	
	public static boolean isLeftForward = true;
	public static boolean isRightForward = true;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    @Override
    public void robotInit() {
        RobotMap.init();
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // OI must be constructed after subsystems. If the OI creates Commands
        //(which it very likely will), subsystems are not guaranteed to be
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
        oi = new OI();
        
        SmartDashboard.putString("DB/String 0", "");
		SmartDashboard.putString("DB/String 1", "");
		SmartDashboard.putString("DB/String 2", "");
		SmartDashboard.putString("DB/String 3", "");
		SmartDashboard.putString("DB/String 4", "");
		SmartDashboard.putString("DB/String 5", "");
		SmartDashboard.putString("DB/String 6", "");
		SmartDashboard.putString("DB/String 7", "");
		SmartDashboard.putString("DB/String 8", "");
		SmartDashboard.putString("DB/String 9", "");
        
		//Resets Gyro
		NavSensor.getInstance().resetGyroNorth(180, 0);
		
		//Add Loops here
		//loooper.add(new LoopName());
		
        looper.startLoops();
        
        String[] autonomousList = {
        	//Add AutoTitles here
        };
        
        //Allows List of AutoTitles to become a selection
        SmartDashboard.putStringArray("Auto List", autonomousList);
        
        //Update history of NavSensor angles
        NavSensor.getInstance().updateHistory();
        
        // Creates the log file in a directory on the roborio
     	File logFile = new File("/home/lvuser/log.txt");
     	try {
     		logFile.createNewFile();
     	} catch (IOException e) {
     		e.printStackTrace();
     	}
        
     	//Creates NavSensor
        try {
	         navSensor = new AHRS(SPI.Port.kMXP);
	    } catch (RuntimeException ex) {
	         DriverStation.reportError("Error instantiating navX MXP:  " + ex.getMessage(), true);
	    }
        // Add commands to Autonomous Sendable Chooser
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
        
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
    }

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    @Override
    public void disabledInit(){

    }

    @Override
    public void disabledPeriodic() {
        Scheduler.getInstance().run();
        
        leftTotalAngle = ((Robot.leftCounter.getRotations())*(4096)) + Robot.leftAbsEnc.getValue();
		rightTotalAngle = ((Robot.rightCounter.getRotations())*(4096)) + Robot.rightAbsEnc.getValue();
    }

    @Override
    public void autonomousInit() {
    	Logger.info("Starting Autonomous");

		// Creates the String based on which autonomous group was selected on
		// the dashboard
		String autoSelected = SmartDashboard.getString("Auto Selector", "None");

		// Makes the field element sides corrospond to actual sides which
		// information from the driver station (or a randomizer in test mode)
		gameData = getPracticeData(false);
		switchesVal = gameData.substring(0, 1);
		scaleVal = gameData.substring(1, 2);

		// Switch Statement to Run the Right Autonomous group Depending on the
		// selected position and switch/scale sides
		
		switch (autoSelected) {
		//case "AutoTitle":
			//setGroup(new AutoTitle());
			//break;
		}
    }

    /**
     * This function is called periodically during autonomous
     */
    @Override
    public void autonomousPeriodic() {
    	
    	SmartDashboard.putString("DB/String 3", "LEFT ROT: " + Robot.leftCounter.getRotations());
		SmartDashboard.putString("DB/String 4", "LEFT VALUE: " + Robot.leftAbsEnc.getValue());
		SmartDashboard.putString("DB/String 5", "RIGHT ROT: " + Robot.rightCounter.getRotations());
		SmartDashboard.putString("DB/String 6", "RIGHT VALUE: " + Robot.rightAbsEnc.getValue());
		SmartDashboard.putString("DB/String 7", "GYRO ANGLE: " + Math.floor(NavSensor.getInstance().getAngle(false)));
		
		leftTotalAngle = ((Robot.leftCounter.getRotations())*(4096)) + Robot.leftAbsEnc.getValue();
		rightTotalAngle = ((Robot.rightCounter.getRotations())*(4096)) + Robot.rightAbsEnc.getValue();
    	
        Scheduler.getInstance().run();
    }

    @Override
    public void teleopInit() {
        // This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to
        // continue until interrupted by another command, remove
        // this line or comment it out.
        Logger.info("Starting Teleop");
        autoScheduler.stop();
        tandemAction.stop();
    }

    /**
     * This function is called periodically during operator control
     */
    @Override
    public void teleopPeriodic() {
    	
    	Scheduler.getInstance().run();
    	
		SmartDashboard.putString("DB/String 3", "LEFT ROT: " + Robot.leftCounter.getRotations());
		SmartDashboard.putString("DB/String 4", "LEFT VALUE: " + Robot.leftAbsEnc.getValue());
		SmartDashboard.putString("DB/String 5", "RIGHT ROT: " + Robot.rightCounter.getRotations());
		SmartDashboard.putString("DB/String 6", "RIGHT VALUE: " + Robot.rightAbsEnc.getValue());
		SmartDashboard.putString("DB/String 7", "GYRO ANGLE: " + Math.floor(NavSensor.getInstance().getAngle(false)));
		
		leftTotalAngle = ((Robot.leftCounter.getRotations())*(4096)) + Robot.leftAbsEnc.getValue();
		rightTotalAngle = ((Robot.rightCounter.getRotations())*(4096)) + Robot.rightAbsEnc.getValue();
    	
    }
    
    /**
	 * Used to get the game specific data on which sides of the field elements
	 * belong to which alliance
	 * 
	 * @param isTest
	 * @return
	 */
	public static String getPracticeData(boolean isTest) {
		if (isTest) {
			String switchesString;
			String scaleString;

			int switchesInt = rand.nextInt(2) + 1;
			int scaleInt = rand.nextInt(2) + 1;

			if (switchesInt == 1) {
				switchesString = "L";
			} else {
				switchesString = "R";
			}

			if (scaleInt == 1) {
				scaleString = "L";
			} else {
				scaleString = "R";
			}

			return switchesString + scaleString + switchesString;

		}

		else {
			try {
				return DriverStation.getInstance().getGameSpecificMessage();
			} catch (Throwable t) {
				Logger.error("No Game Message Recieved");
				return "IDK";
			}
		}

	}
    
    public static String parseMatchTime() {
		double s = DriverStation.getInstance().getMatchTime();

		if (s != -1.0) {
			if (DriverStation.getInstance().isAutonomous()) {

				int t = (int) (15 - Math.ceil(s));
				return ":" + Integer.toString((int) t) + " (Auton)";

			} else if (DriverStation.getInstance().isOperatorControl()) {

				int t = (int) (135 - Math.ceil(s));
				return Integer.toString((int) Math.floor(t / 60)) + ":" + Integer.toString((int) t % 60) + " (TeleOp)";

			} else {

				return "Disabled";

			}

		} else {

			return "Not Practice";

		}

	}
    
}
